
# By finding the first arrangement to contain over 10^12 = 1,000,000,000,000
# discs in total, determine the number of blue discs that the box would contain.

# Solution Idea:
# Let b be the number of blue discs and n be the total number of discs.
# The probability of picking two blue discs is P(BB) = (b/n) * ((b-1)/(n-1)).
# Given P(BB) = 1/2, we get the Diophantine equation 2*b*(b-1) = n*(n-1).
#
# This can be transformed into the Pell-type equation x^2 - 2*y^2 = -1
# with the substitutions x = 2n - 1 and y = 2b - 1.
#
# The solutions (x_k, y_k) can be generated by the recurrence relation:
# x_{k+1} = 6*x_k - x_{k-1}
# y_{k+1} = 6*y_k - y_{k-1}
#
# We need to find the first solution where n > 10^12, which means x > 2 * 10^12.
# We can start with the first few solutions and iterate until we cross the threshold.
#
# Initial solutions:
# (b, n) = (1, 1) -> (y, x) = (1, 1)
# (b, n) = (3, 4) -> (y, x) = (5, 7)
# (b, n) = (15, 21) -> (y, x) = (29, 41)

def solve():
    """
    Finds the number of blue discs in the first arrangement with over 10^12 discs
    where the probability of picking two blue discs is 1/2.
    """
    limit = 10**12

    # Start with two consecutive solutions for the recurrence
    # (b,n) = (3,4) -> y=5, x=7
    # (b,n) = (15,21) -> y=29, x=41
    y_prev, x_prev = 5, 7
    y_curr, x_curr = 29, 41

    n_curr = (x_curr + 1) // 2

    while n_curr <= limit:
        x_next = 6 * x_curr - x_prev
        y_next = 6 * y_curr - y_prev

        x_prev, x_curr = x_curr, x_next
        y_prev, y_curr = y_curr, y_next

        n_curr = (x_curr + 1) // 2

    # The loop terminates when n_curr > limit.
    # The corresponding number of blue discs is b_curr.
    b_curr = (y_curr + 1) // 2
    return b_curr

if __name__ == "__main__":
    result = solve()
    print(result)

"""
Project Euler Problem 51: Prime digit replacements

Problem:
By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.

Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.

Solution Idea:
We are looking for the smallest prime number that can be part of an "8-prime family". A family is created by taking a number, identifying a set of digit positions to replace, and then substituting the digits '0' through '9' into those positions.

The most direct approach is to iterate through primes in increasing order and, for each prime, check if it belongs to an 8-prime family. The first one we find will be the smallest.

1.  **Sieve for Primes**: We need to check for primality efficiently. A Sieve of Eratosthenes up to a reasonable limit (e.g., one million) is the best method.

2.  **Iterate Through Primes**: We will loop through all prime numbers `p` generated by the sieve.

3.  **Identify Replacement Patterns**: For a given prime `p`, a replacement pattern must be based on its existing digits. For example, in `56003`, the pattern of replacing the two '0's is a candidate. We can't just invent a pattern; it must correspond to one of the repeating digits within the prime `p` itself.

4.  **Algorithm**:
    a.  Generate primes up to a limit (e.g., 1,000,000) using a sieve.
    b.  Iterate through each prime `p` from the sieve.
    c.  Convert the prime `p` to its string representation, `s`.
    d.  Identify the unique digits in `s`. For each unique digit `d_rep` that appears in `s`, we test the pattern formed by replacing all occurrences of `d_rep`.
    e.  For each such pattern (mask):
        i.   Initialize a `prime_family_count` to 0.
        ii.  Loop through the replacement digits `r` from '0' to '9'.
        iii. Create a new number string by replacing the digits in `s` at the masked positions with the new digit `r`.
        iv.  **Crucially**, if the first digit is part of the replacement pattern, the replacement `r='0'` is invalid as it would create a number with fewer digits. We skip this case.
        v.   Convert the new string to an integer `new_n` and check if it's prime using our sieve.
        vi.  If `new_n` is prime, increment `prime_family_count`.
    f.  If, after checking all 10 replacements for a given pattern, the `prime_family_count` is 8, we have found our answer. Since we are iterating through primes `p` in increasing order, the first `p` that is part of such a family is the smallest one. We can return `p` and terminate.
"""
import itertools

def sieve(n):
    """Generate a boolean list of primes up to n using Sieve of Eratosthenes."""
    primes = [True] * (n + 1)
    primes[0] = primes[1] = False
    for i in range(2, int(n**0.5) + 1):
        if primes[i]:
            for multiple in range(i*i, n + 1, i):
                primes[multiple] = False
    return primes

def solve():
    """
    Finds the smallest prime which, by replacing part of the number,
    is part of an eight prime value family.
    """
    limit = 1_000_000
    is_prime = sieve(limit)
    
    for p in range(11, limit): # Start from 11, as single digits don't apply
        if not is_prime[p]:
            continue
            
        s = str(p)
        # Check for patterns based on repeated digits
        for digit_to_replace in set(s):
            
            mask = [c == digit_to_replace for c in s]
            
            # Skip if no digits are being replaced (shouldn't happen with set)
            if not any(mask):
                continue

            family_count = 0
            for r_digit in range(10):
                # Skip leading zero replacements
                if mask[0] and r_digit == 0:
                    continue
                
                new_s_list = list(s)
                for i in range(len(s)):
                    if mask[i]:
                        new_s_list[i] = str(r_digit)
                
                new_n = int("".join(new_s_list))
                
                # Check if the generated number is prime
                if is_prime[new_n]:
                    family_count += 1
            
            if family_count == 8:
                return p

    return "Not found within the limit."

if __name__ == "__main__":
    print(solve())

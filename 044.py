"""
Project Euler Problem 44: Pentagon numbers

Problem:
Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?

Solution Idea:
We need to search for two pentagonal numbers, `P_j` and `P_k`, such that `P_k + P_j` and `P_k - P_j` are also pentagonal, and the difference `D = P_k - P_j` is as small as possible.

1.  **Pentagonal Number Check**: We need an efficient way to check if an arbitrary number `x` is a pentagonal number. A number `x` is pentagonal if there is an integer solution `n` to the equation `x = n(3n-1)/2`. We can solve this for `n` using the quadratic formula:
    `n = (1 + sqrt(1 + 24x)) / 6`
    For `n` to be a positive integer, `1 + 24x` must be a perfect square, and the result of `(1 + sqrt(1 + 24x))` must be divisible by 6. This gives us a fast `is_pentagonal(x)` test.

2.  **Search Strategy**: We can iterate through pentagonal numbers and check pairs.
    - We will generate pentagonal numbers `P_k` for `k = 1, 2, 3, ...`.
    - For each `P_k`, we will check it against all previously generated pentagonal numbers `P_j` (where `j < k`).
    - For each pair `(P_j, P_k)`, we calculate their sum `S = P_k + P_j` and difference `D = P_k - P_j`.
    - We then use our `is_pentagonal` function to check if both `S` and `D` are pentagonal.

3.  **Minimizing D**:
    - We are looking for the minimum possible `D`. We will keep track of the smallest `D` found so far, let's call it `min_D`.
    - We can optimize the search. As we iterate through `k`, the differences `P_k - P_j` will generally increase.
    - Once we find a valid pair and have a `min_D`, we can prune the search. For a given `k`, as we check `j` in descending order (from `k-1` down to 1), the difference `D = P_k - P_j` increases. If this `D` becomes larger than our current `min_D`, we know that no further `j` for the current `k` will produce a smaller `D`, so we can break the inner loop and move to the next `k`.

4.  **Stopping Condition**: The overall search can be stopped when the difference between consecutive pentagonal numbers (`P_k - P_{k-1}`) becomes larger than the smallest `min_D` we have found. At that point, any new pair we check will have a difference larger than `min_D`, so we know we have found the global minimum. However, a simple search up to a reasonable limit (e.g., a few thousand for `k`) is sufficient and fast enough to find the solution.
"""
import math

def is_pentagonal(x):
    """Checks if a number x is a pentagonal number."""
    if x <= 0:
        return False
    # A number is pentagonal if n = (1 + sqrt(1 + 24x)) / 6 is an integer.
    val = 1 + 24 * x
    sqrt_val = math.isqrt(val)
    if sqrt_val * sqrt_val != val:
        return False
    return (1 + sqrt_val) % 6 == 0

def solve():
    """
    Finds the minimized difference D between two pentagonal numbers whose sum and difference are also pentagonal.
    """
    min_D = float('inf')
    pent_numbers = []
    # A search limit of 3000 is sufficient to find the solution.
    limit = 3000

    for k in range(1, limit):
        p_k = k * (3 * k - 1) // 2
        
        # Iterate j backwards because smaller differences (j close to k) are more likely to be the minimum.
        for p_j in reversed(pent_numbers):
            diff = p_k - p_j
            
            # Optimization: if the current difference is already larger than a found solution,
            # we can stop checking for this k, because any further p_j will be smaller, making diff larger.
            if diff >= min_D:
                break
                
            summ = p_k + p_j
            
            if is_pentagonal(diff) and is_pentagonal(summ):
                min_D = diff
                # We found a new minimum for this k. We can break the inner loop
                # as any further p_j will result in a larger difference.
                break
        
        pent_numbers.append(p_k)
    
    return min_D

if __name__ == "__main__":
    print(solve())
